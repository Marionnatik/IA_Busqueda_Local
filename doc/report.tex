\documentclass{article}

\setlength{\paperwidth}{210mm}
\setlength{\paperheight}{297mm}
\setlength{\hoffset}{-12mm}
\setlength{\voffset}{-10mm}
\setlength{\evensidemargin}{0mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\topmargin}{0mm}
\setlength{\headheight}{0mm}
\setlength{\headsep}{5mm}
\setlength{\textheight}{256.2mm}
\setlength{\textwidth}{184.2mm}
\setlength{\marginparsep}{0mm}
\setlength{\marginparwidth}{0mm}
\setlength{\footskip}{5mm}
\setlength{\marginparpush}{0mm}


\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}

\pagestyle{myheadings}
\markright{IA - Práctica de búsqueda local}

\title{\Huge{Práctica de búsqueda local} \\
\vspace{15mm}
   \Large{Laboratorio de Inteligencia Artificial}}
\author{Marion Not - Michael Boris Mandirola}
\date{Primavera 2010-2011}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section*{Introducción}
El objetivo de esta práctica es analizar y resolver un problema de optimización
logística mediante algoritmos de búsqueda local. Definiremos la representación
del problema como estado y estudiaremos la influencia de los elementos que
intervienen en esta búsqueda y que hemos visto a clase (estado inicial, función
heurística y operadores) bajo diferentes condiciones sobre los parámetros del
problema.

Usaremos dos tipos de algoritmos de búsqueda local : el Hill Climbing y el
Simulated Annealing. Como el objetivo de la práctica no es la implementación de
estos algoritmos, usaremos las herramientas proporcionadas por el package AIMA. 
En el caso del Simulated Annealing, también estudiaremos la influencia de los 
parámetros del algoritmo.

\section{Representación del problema}
El contexto del problema es el siguiente : Una empresa de transporte está
contratada por una compañía para gestionar el encaminamiento de productos desde
un almacén central hasta unos centros de producción.

Cada día, los centros realizan un conjunto de peticiones de diferentes tipos y 
cantidades de productos que se tienen que entregar a una cierta hora. El pago se
realiza en función de la cantidad de productos entregados y la puntualidad con
la cual han llegado al centro.

La empresa de transporte quiere optimizar estas entregas, sabiendo que manda un
transporte a cada centro en cada hora en punto del día.
No tenemos que gestionar la recogida de productos en el almacén, ni el recorrido
de los transportes, ni la cantidad de camiones físicos que se necesitan :
Suponemos que la empresa dispone de una flota suficiente para hacer todas las
entregas en tiempo.
Solucionaremos este problema para un solo día, pues las peticiones no entregadas
no estarán desplazadas al día siguiente.

\subsection{Identificación de los elementos relevantes}
Para cada problema, tendremos unos elementos constantes, unos elementos
específicos del problema y unos elementos variables que se tendrán que
determinar para llegar a la solución.

\subsubsection{Constantes}
\begin{description}
\item[Centros de producción :] Como lo hemos dicho, el número de centros esta 
fijado a 6.
\item[Horas de entrega :] Las entregas se harán a cada hora en punto del día. La
primera se hará a las 8 y la última a las 17, para un total de 10 horas de
entrega.
\item[Transportes :] Tendremos un transporte para cada hora del día y cada
centro, es decir 60 transportes en total. La capacidad de los camiones usados
sera de 500, 1000 o 2000kgs, en proporción variable.
\item[Peticiones :] Las peticiones se harán para una de las horas de entregas y
para una cantidad de productos de 100, 200, 300, 400 o 500kgs.
\end{description}

\subsubsection{Elementos específicos del problema}
\begin{description}
\item[Peticiones :] Todas las peticiones estarán generadas al principio de la
resolución mediante unos parámetros especificados por el usuario. Por lo tanto,
serán diferentes para cada problema. Se tendrán que especificar :
\begin{itemize}
\item El número de peticiones
\item La distribución de probabilidad de cantidad de productos de las entregas
\item La distribución de probabilidad de horas de entrega
\end{itemize}
Las peticiones estarán repartidas de forma equiprobable entre los centros.
El tipo de producto pedido no tienen ninguna influencia.
\item[Transportes :] Se tendrá que especificar la distribución de probabilidad
de capacidades de los transportes, es decir cuantos de los 60 transportes
tendrán una capacidad de 500kgs, cuantos de 1000 y cuantos de 2000.
\item[Parámetros de la búsqueda :] Se precisará que tipo de estado inicial,
algoritmo de búsqueda y función heurística se tienen que usar. 
\end{description}

\subsubsection{Elementos de la solución}
Para llegar a la solución, se tendrán que determinar :
\begin{itemize}
\item La repartición de los 60 transportes, es decir que capacidad de transporte
se asignará à cada hora de cada centro.
\item La repartición de las peticiones en los transportes.
\end{itemize}

\subsection{Definición del Estado}
Hemos escogido una representación en acuerdo con la decripción del problema de
la parte anterior.
\subsubsection{Implementación}
\begin{center} \includegraphics[width=14cm, angle=90]{clases}\\
{\it Fig. 1.1 : Diagrama de clases de representación del problema.} \end{center}
\begin{itemize}
\item Una clase singleton Constantes contiene los elementos comunes a todos los
problemas.
\item Los elementos especificos serán leidos desde un fichero .txt y usados por
el Principal para generar un problema dado, es decir un conjunto de instancias
de la clase Petición y un Estado ``vacio'', donde las peticiones estarán
repartidas entre las 6 instancias de clase Centro pero no entregadas. Se crearán
11 instancias de clase Transporte : una para cada hora del día y una para
guardar las peticiones no entregadas.
\item A continuación, se generará el estado inicial de la búsqueda, es decir que
se atribuirá una capacidad a cada unos de los 60 transportes que corresponden a
una hora (los Transporte de peticiones no entregadas tendrán capacidad máxima) y
se repartirán las peticiones según la estrategia especificada.
\item Durante la resolución del problema, las peticiones se desplazarán de un
Transporte a otro, dentro del mismo Centro. Tambien se podrá modificar la
repartición de las capacidades entre todos los 60 transportes. Ver la sección
siguiente para detalles sobre los operadores.
\end{itemize}
\subsubsection{Tamaño del espacio de búsqueda}
Si tenemos $N$ peticiones, repartidas igualmente entre 6 centros ($\frac{N}{6}$
peticiones/centro), que se pueden afectar a cualquier de los $10+1$ transportes,
contamos con $O(11^N)$ configuraciones posibles para la repartición de las
peticiones.\\
Si añadimos que cada uno de los 60 transportes puede tener una de 3 capacidades,
es decir $O(3^{60})$ configuraciones posibles, tenemos un total de
\textbf{$O(11^Nx3^{60})$ estados posibles}.\\
\indent Se tiene que tener en cuenta que en verdad la suma de pesos de las
peticiones afectadas a un transporte no puede exceder su capacidad, y que
tenemos un número limitado de transportes de cada capacidad : Eso reduce el
tamaño del espacio de búsqueda.\\
\indent Este tamaño es bastante importante, pero considerando que hacemos una
búsqueda local y que recorriremos solo una fracción del espacio, no es excesivo.

\subsection{Operadores}
%descripcion detallada, condiciones de aplicacion, efecto
%factor de ramificacion
%justificacion de la eleccion
Nuestro conjunto de operadores està echo por el desplazamiento de una petición y el cambio de operadores.
\subsubsection{Desplazamiento de una petición dentro de un centro}
El operador de desplazamiento pone una petición de el transporte pertinente a una hora, en una otra. Este operador se puede aplicar solo si en la hora destino queda una capacidad disponible bastante grande para añadir la petición en cuestión. Tampoco se puede desplazar una petición a la misma hora de orígen o a un otro centro.
El efecto es disfrutar los huecos que se crean después de cambios de camiones para entregar peticiones que estan entre la no entragadas o que estan entregadas mas tarde de su hora de entrega.
El factor de ramificación es O(Nºhores X Nº peticiones) 
Una variante de este operador sería prohibendo el desplazamiento de una petición a el grupo de no entregadas. La magnitud de el factor de ramificación no cambia pero se elimina la generación de muchos succesores que no pueden ser escogidos de el Hill Climbing porqué su heurística siempre da un resultado negativo sobre estos. De todas maneras, esta variante no puede ser implementada porqué una consecuencia directa sería un número muy grande de estados (a veces el primero) sin algun succesor válido y esto bloquearia el Simulated Annealing. 
\subsubsection{Intercambio de capacidades de camiones}
El intercambio de capacidades de camiones intercambia las capacidades de dos transportes entre dos horas. Este operador se puede aplicar solo si la capacidad ocupada de cada transporte es inferior de la capacidad de el transporte que va a recibir. Tampoco se puede intercambiar camiones que tienen la misma capacidad. El efecto es cambiar la capacidad total disponible en un centro o ponerlas en horas diferente. Así se podría poner mas capacidad en los centros que la necesitan o en horas más tempranas para adelantar peticiones en retraso. 
El intercambio de camiones en si mismo no hace cambiar ninguna heurística así que es necesario desplazar una petición en el mismo operadors. Así que se pone una petición no entregada en el transporte que ha subido su capacidad; si no hay peticiones no entregadas, se pone la más valorable de la que se entregan más tarde.
El factor de ramificación es $O(Nºhores^2)$.
\subsubsection{Operadores no implementados}


\subsection{Funciones Heurísticas}
%descripcion y analisis de los factores que intervienen en las heuristicas
%justificacion de la eleccion de estas heuristicas y de las ponderaciones
%explicacion del impacto de las heuristicas en la busqueda
\subsubsection{Maximización de la ganancia}
\begin{description}
\item[Definición de la ganancia :]
Para cada petición, la compañia pagará a la empresa de transporte un importe
basado sobre el precio base de las peticiones (indicado en la tabla 1), que
depende unicamente de la cantidad de productos pedida, y la puntualidad de la 
entrega.\\
\begin{center}
\begin{tabular}{|l|l|}
\hline
Peso & Precio\\
\hline
100 y 200 kg & {\it peso} euros\\
300 y 400 kg & 1,5x{\it peso} euros\\
500 kg & 2x{\it peso} euros\\
\hline
\end{tabular}\\
{\it Tabla 1.1 : Precio base de las entregas.} \end{center}
El importe pagado para cada petición entregada será el precio base menos unos
20\% del mismo para cada hora de retraso, es decir que para mas de 5h de retraso
le tocara pagar a la empresa de transporte. Si una petición no esta entregada enel día, la empresa de transporte tendrá que pagar el precio base de la petición
mas unos 20\% del mismo para cada hora hasta las 17.\\

Ejemplo : Para cada peso de petición, en la tabla 2 se indican los
importes correspondientes a una entrega en tiempo, una entrega con 1 y 7 horas
de retraso y no entrega, considerando que las peticiones se tenián que entregar
a las 10.
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
Peso & En tiempo ($<$10h) & Retraso 1h (=11h) & Retraso 7h (=17h) &
No entregada\\
\hline
100kg & 100 & 80 & -40 & -240\\
200kg & 200 & 160 & -80 & -560\\
300kg & 450 & 360 & -180 & -1080\\
400kg & 600 & 480 & -240 & -1440\\
500kg & 1000 & 800 & -400 & -2800\\
\hline
\end{tabular}\\
{\it Tabla 1.2 : Ejemplos de importes.} \end{center}
\end{description}

\subsubsection{Minimización de la diferencia entre hora de entrega deseada y
efectiva}
El retraso en la entrega de una petición es simplemente la diferencia entre la
hora de entrega deseada y la efectiva. Si la petición no esta entregada en el
día, el retraso es la diferencia entre la hora de entrega deseada y las 8 del
día siguiente. No obstante, como solucionemos el problema solo para una jornada,
no se tendra que gestionar la entrega de estas peticiones.

\subsection{Estados Iniciales}
%justificacion de la eleccion de los estados (bondad de la solucion, coste,
% adaptacion a cada algoritmo)
%descripcion de la implementacion

En un primer momento hemos intentado generar estados diferentes con lógicas muy diferentes con la idea de buscar nuestros estados iniciales entre un grupo más amplio y en particular elegir dos estados que tengan características muy diferentes. Es decir tiempo de generación de el estado inicial, complejidad de el algoritmo, posibilidades de evolución, calidad de la solución buscada.

\subsubsection{Cuanto antes}
A) Este estado divide los camiones de manera ecua entre los centres asignando los camiones con mas capacidad a los transportes mas tempranos. Las entregas están entregadas lo mas pronto posible: se hace una lista de peticiones pertinentes a un centro, se ordenan crecientemente por tiempo de entrega y disminuyendo por precio y se pasa toda la lista poniendo las peticiones en el transporte más pronto que tiene más tiempo libre.

\subsubsection{Repartición por hora}
Este estado ordena las peticiones por precio y hora. Por cada petición, intenta entregarla en la hora pertinente con este algoritmo:
Si no hay camión, se pone el camión disponible más pequeño y la petición, si hay camión y bastante capacidad libre también se pone la petición. Si hay camión de capacidad inferior a la capacidad máxima y hay disponibilidad de camiones más grandes, se asigna un camión mas grande en lugar de lo más pequeño y se pone la petición. Además, si no hay camiones libres más grandes intenta hacer lo mismo en las horas más tempranas hasta las 8. Si no tiene éxito, intenta hacerlo en las horas después hasta las 17.
Después si hay oras sin camión, se asignan los camiones que se quedan libres.

\subsubsection{First-Fit}
F) Los camiones se asignan como en el estado A. Sin ordinación se iteran todas las peticiones intentando ponerlas en su hora de pertinencia. Después, iterativamente por cada petición se intenta poner, las que se quedan no entregadas, en las horas más tempranas de la suya hasta las 8 y si no se tiene éxito, se intenta hacerlo en las horas después hasta las 17.

\subsubsection{Vacio}
V) Los camiones se asignan como en el estado A. Las peticiones se quedan todas no entregadas.

\newpage
\section{Implementación}

\subsection{Generación de problemas aleatorios}

\subsection{Uso del AIMA}

\subsection{Ejecución de pruebas}
El programa efectúa las pruebas sacando los parametros necesarios de ficheros de texto. Los ficheros estan organizados en la siguiente manera:
\begin{itemize}
\item Linia 1 : Numero de pruebas con estos parametros - 1 Integer
\item Linia 2 : Numero de peticiones - 1 Integer
\item Linia 3 : Distribucion de capacidad de los camiones - 3 Integers para 500, 1000 y 2000kg - La suma de los 3 debe ser igual a 60.
\item Linia 4 : Distribucion de pesos de las peticiones - 5 Floats para 100 hasta 500kg - La suma de los 5 debe ser igual a 1.
\item Linia 5 : Distribucion de las horas de entrega - 10 Floats para 8h hasta 17h - La suma de los 10 debe ser igual a 1.
\item Linia 6 : Estrategia para generar el estado inicial - 1 Char
\item Linia 7 : Tipo de algoritmo - String - Puede ser "hc" o "sa".
\item Linia 8 : Tipo de heuristica - String - Puede ser "gan" o "ret".
La separacion entre la parte entera y decimal puede ser una coma (,) o un punto (.), si sale un error "formato no valido", intenta cambiar eso.
\end{itemize}
Cada experimento, pero, necesita una batería de pruebas con diferentes parametros. Así tenemos una carpeta para cada experimento con diferentes ficheros para generar pruebas. Un {\it bash script} recibe en input el numero de el experimento y resuelbe el problema con los ficheros de prueba pertinentes.

\subsection{Recuperación de resultados}
%output
Por cada problema son generados dos ficheros de salida, uno con el estado inicial y el otro con el estado final. En estos ficheros tenemos:
\begin{itemize}
\item El beneficio
\item El retraso
\item Los centros y por cada centro
	\begin{itemize}
		\item Cantidad de peticiones no entregadas
		\item Las horas y por cada hora de entrega
		\begin{itemize}		
			\item La capacidad total
			\item La capacidad ocupada
			\item La capacidad libre
			\item Las peticiones no entregadas y por cada petición		
			\begin{itemize}
			\item El identificador
			\item La hora de entrega supuesta
			\item La cantidad
			\item El precio
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{itemize}
También hay un fichero de estadísticas por cada experimento a que vamos anadiendo datos sobre las pruebas. Este fichero está organizado como un CSV y por cada prueba tenemos registrados:
\begin{itemize}
\item El numero de nodos desarrollados. 
\item El beneficio.
\item El percentaje de mejoría de el beneficio.
\item El retraso
\item El percentaje de mejoría de el retraso.
\item El tiempo de ejecución de la búsqueda.
\end{itemize}
Una linea vacía y una linea con el título del fichero de input dividen los diferentes grupos de pruebas (resultado de diferentes ejecuciones de el programa).

\newpage

\section{Pruebas}

\subsection{Pruebas realizadas y Resultados}

\subsubsection{Generalidades}

\begin{description}
\item[Condiciones de experimentación por defecto :] Si no se dice otra cosa, los
experimentos se hacen para 250 peticiones con pesos y horas de entrega
equiprobables. Se usa el algoritmo de Hill Climbing y la heurística de
maximización de la ganancia.
\item[Numero de pruebas :] Al largo de los experimentos, hemos notado que en
muchos casos, solo una pequeña fracción de los estados iniciales evolucionan, en
particular cuando tenemos estados iniciales ``avanzados'' que se pueden
dificilmente mejorar. Por eso, hemos decidido hacer un número de pruebas elevado
(al menos 50) para cada experimento, y cuando es relevante considerar solo los
resultados de los casos donde el estado mejora.
\end{description}

\subsubsection{Experimento 1 : Elección del conjunto de operadores}
\begin{description}
\item[Elementos comparados :] Queremos elegir el conjunto de operadores que
vamos a usar en el resto de experimentos, entre los tres operadores que tenemos
implementados : \emph{Desplazamiento de peticion (Op1), intercambio de camiones
(Op2) y intercambio de peticiones (Op3)}. Hemos decidido probar dos conjuntos :
\begin{enumerate}
\item Op1 + Op2
\item Op1 + Op2 + Op3
\end{enumerate}
Hemos decidido incluir imperativamente los operadores 1 y 2 en el conjunto, ya
que Op1 es el único operador que nos permite desplazar peticiones no entregadas
a las entregadas y Op2 es el único que mueve los camiones. Principalmente,
estudiaremos la influencia del operador Op3 sobre el tiempo de ejecucción, la
bondad de la solución y el porcentaje de estados que mejoran.
\item[Numero de pruebas :] 1500 pruebas para cada conjunto. Hemos escogido un
número elevado para poder comparar el porcentaje de estados que mejoran.
\item[Contexto :] Hemos escogido el estado inicial ``Repartición por hora'', que
se puede mejorar bastante frecuentemente y no consume demasiado tiempo.
\item[Resultados :]
\begin{tabular}{|l|l|l|l|}
\hline
Conjunto & \% de estados mejorados & Mejoria del beneficio (global) & Tiempo de
ejecución/iteración\\
\hline
Op1 + Op2 & 5,7\% & 3\% (0,17\%) & 23,25ms\\
\hline
Op1 + Op2 + Op3 & 15,3\% & 1,5\% (0,22\%) & 75,39ms\\
\hline
\end{tabular}
\begin{center}
{\it Tabla 3.1 : Resultados del experimento 1.}
\end{center}

\item[Conclusiones :] El operador Op3 provoca la evolución de mas estados, pero
en media la solución hallada es menos buena. Ademas, el tiempo de ejecución esta
multiplicado por 3. Por estas razones, en el caso general usaremos el primer
conjunto de operadores : Op1 + Op2.

Sin embargo, recordamos que el operador Op3 se podra usar para obtener
resultados en casos donde pocos estados evolucionan.
\end{description}

\subsubsection{Experimento 2 : Elección de los estados iniciales}
\begin{tabular}{|l|l|l|l|l|}
\hline
Estrategia & T. gen. (ms) & N. it. & T. ejec. (t. ejec/it) (ms) & Benef.
(mejora)\\
\hline
Cuanto antes & 2,62 & 1,00 & 65 (65) & 95065 (0,00\%)\\
\hline
Reparticion por hora & 3,78 & 1,40 & 106 (73) & 96930 (0,42\%)\\
\hline
First-fit & 0,386 & 2,15 & 95 (46) & 81251 (1,49\%)\\
\hline
Vacio & 0,0193 & 220 & 37560 (170) & 89923 (141\%)\\
\hline
\end{tabular}

> b!!! me gusta! <
> a no mejora pero es bueno
> f no da buenos resultados
> v es demasiado lento

\subsubsection{Experimento 4 : Influencia del numero de peticiones}
200p : 
t.gen 0,579
n it 2,04 / 2,47
ben 94600 / 93800
mej 0,316 / 0,53
t. tot 77,0ms / 206
t/it 40,7 / 88,2

250 :
t.gen 0,887
n it 1,22 / 1,48
ben 98000 / 97000
mej 0,164 / 0,259
t tot 32,5ms / 132
t/it 26.6 / 86,4

300 :
t. gen 1,01
n it 1 / 2,76
ben 69900 / 70300
mej 0 / 0,737
t tot 29.0 / 408
t/it 29 / 145

350
t.gen 1.61
n it 1 / 3,62
ben 35400 / 37100
mej 0 / 2,58
t tot 28.8 / 855
t/it 28.8 / 243

400
t.gen 1,15
n it 1 / 2,69
ben -456 / 222
mej 0 / 30,31
t tot 32.7 /935
t/it 32.7 / 358

450
t gen 1.67
n it 1 / 1,92
be -36100 / -36300
mej 0 / 0,856
t tot 34.85 / 960
t/it 34.85 / 505

500
t gen 1.75
n it 1 / 1,97
be -72600 / -73000
mej 0 / 0,55
t tot 42.4 / 1650
t/it 42.4 / 833

> t gen sube
> no mejora
> ben baja excepto al primero xq teniamos todo entregado
> t. tot sube 

\subsubsection{Experimento 5 : Influencia de la heuristica}
100 tests

200
n.it 2,46 / 2,22
ben 93453 / 93290
mej 0,454 / 0,346
ret 68,6 / 64,7
mej 4,40 / 5,78
t 91,58 / 85,1

250
n.it 1,15 / 1,02
ben 97672 / 97675
mej 0,127 / 0,0216
ret 755 / 748
mej 0,28 / 0,0542
t 31,93 / 26,40

300
n.it 1 / 1
ben 69036 / 69970
mej 0 / 0
ret 2039 / 2041
mej 0 / 0
t 24,69 / 24,71


\subsection{Interpretacion de los resultados}
% explicaciones y analisis detallada
% comparar los resultados con lo que se esperaba
% hacer los experimentos del enunciado y contestar las preguntas
% hacer tb mas experimentos para complementar

\subsection{Influencia de la solución inicial}
%coste de creacion
% influenca en la bondad de la solucion y en el coste del algoritmo

\subsection{Influencia de los operadores}
% comparacion entre conjuntos de operadores
% impacto sobre el coste temporal y bondad de la solucion

\subsection{Influencia de la heurística}
% comparacion entre las dos heuristicas, impacto en tiempo y bondad de solucion
% hacer experimentos para ver la influenca de las ponderaciones

\end{document}
